{
    "sourceFile": "src/source/components/react-dom.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1667471546503,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1667471546503,
            "name": "Commit-0",
            "content": "//初始化\r\nfunction render(vdom, container) {\r\n    // 本质就是挂载，因container本身存在于文档之中，所以挂载操作会触发渲染\r\n    mount(vdom, container);\r\n}\r\n\r\nfunction mount(vdom, container) {\r\n    // 将第一个参数变成真实DOM，插入到第二个参数挂载元素上\r\n    const DOM = createDOM(vdom);\r\n    container.append(DOM);\r\n}\r\n\r\n//创建dom\r\nexport function createDOM(vdom) {\r\n    const type = getType(vdom);\r\n    const getDom = typeMap.get(type);\r\n    let DOM = getDom(vdom);\r\n    //vdom和DOM一一对应.这里DOM挂到vdom上，这样从instance.curRenderVdom.dom就可以拿到现存dom了\r\n    type !== 'text' && (vdom.dom = DOM);\r\n    console.log(vdom);\r\n    return DOM;\r\n}\r\n//根据type类型分判断\r\nconst typeMap = new Map([\r\n    ['text', handleTextType],\r\n    ['element', handleElementType],\r\n    ['function', handleFunctionType],\r\n    ['class', handleClassType],\r\n]);\r\n// vdom有四种类型\r\n// 1. \"直接就是字符串\"\r\nconst handleTextType = (vdom) => document.createTextNode(vdom || '');\r\n// 2. {type:'div',props:{...}}  type是字符串，组件根元素是原生标签\r\nconst handleElementType = (vdom) => createElementDOM(vdom);\r\n// 3. {type:function X(){ return <h1/>},props:{...}}，type是函数，返回值才是vdom\r\nconst handleFunctionType = (vdom) => {\r\n    const {\r\n        type: fn,\r\n        props\r\n    } = vdom;\r\n    const vdomReturn = fn(props);\r\n    return createElementDOM(vdomReturn);\r\n};\r\n// 4. {type: class x ...{ render(){return <h1/>} },props:{///}}，type是函数，\r\n// 但是静态属性有isClassComponent，实例的render函数返回值才是vdom\r\nconst handleClassType = (vdom) => {\r\n    const {\r\n        type: classFn,\r\n        props\r\n    } = vdom;\r\n    const instance = new classFn(props);\r\n    // 这里将本身的vdom 绑定到实例上，再在vdom转化成dom的时候，再把dom挂上来（不是vdomReturn，不然找不到curRenderVdom）\r\n    instance.curRenderVdom = vdom;\r\n    const vdomReturn = instance.render(props);\r\n    console.log(vdomReturn);\r\n    return createElementDOM(vdomReturn);\r\n};\r\n\r\n// 根据vdom得到类型，从而根据类型，调用相应的方法生成真实DOM\r\nconst getType = (vdom) => {\r\n    const isTextNode =\r\n        typeof vdom === 'string' || typeof vdom === 'number' || vdom == null;\r\n    if (isTextNode) return 'text';\r\n\r\n    const isObject = typeof vdom === 'object';\r\n    const isElementNode = isObject && typeof vdom.type === 'string';\r\n    if (isElementNode) return 'element';\r\n\r\n    const isFn = isObject && typeof vdom.type === 'function';\r\n    return isFn && vdom.type.isClassComponent ? 'class' : 'function';\r\n};\r\n\r\n\r\n\r\nfunction createElementDOM(vdom) {\r\n    const {\r\n        type,\r\n        props\r\n    } = vdom;\r\n\r\n    let DOM = document.createElement(type);\r\n    if (props) {\r\n        updateProps(DOM, props);\r\n        const {\r\n            children\r\n        } = props;\r\n        children && updateChildren(DOM, children);\r\n    }\r\n    return DOM;\r\n}\r\n//处理props\r\nfunction updateProps(DOM, props) {\r\n    // 正常遍历就好，特殊的特殊处理\r\n    for (const key in props) {\r\n        if (key === 'children') continue;\r\n        // 事件处理！！\r\n        if (/on[A-Z]+/.test(key)) {\r\n            DOM[key.toLowerCase()] = props[key];\r\n            continue;\r\n        }\r\n        if (key === 'style') {\r\n            updateStyle(DOM, props[key]);\r\n            continue;\r\n        }\r\n        DOM[key] = props[key];\r\n    }\r\n\r\n    function updateStyle(DOM, styleObj) {\r\n        for (const key in styleObj) {\r\n            DOM.style[key] = styleObj[key];\r\n        }\r\n    }\r\n}\r\n//处理children\r\nfunction updateChildren(DOM, children) {\r\n    // 单个节点，直接插入（挂载）到DOM上; 多个节点，遍历插入\r\n    const isOneChildren = !Array.isArray(children);\r\n    isOneChildren\r\n        ?\r\n        mount(children, DOM) :\r\n        children.forEach((child) => mount(child, DOM));\r\n}\r\n\r\nconst ReactDOM = {\r\n    render,\r\n};\r\nexport default ReactDOM;"
        }
    ]
}